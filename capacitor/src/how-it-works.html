<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How repo.md Works | Convert GitHub Repo to Readme</title>
  <meta name="description" content="Learn how repo.md seamlessly converts GitHub repositories into clean, AI-friendly markdown documentation, and how it's deployed.">
  <link rel="canonical" href="https://repo-md.com/how-it-works" />
  <link rel="stylesheet" href="styles.css">
  <!-- Add JSON-LD Schema if applicable -->
</head>
<body>
  <header class="header">
    <a href="/" style="text-decoration: none; color: inherit;"><h1>repo.md</h1></a>
    <nav class="main-nav">
      <a href="/how-it-works.html">How It Works</a>
      <a href="/sponsor.html">Sponsor</a>
    </nav>
  </header>
  <div class="container">
    <h1>How repo.md Works</h1>
    <p class="intro">
      <code>repo.md</code> transforms GitHub repositories into comprehensive Markdown documents.
      This page delves into the technical details of its core functionality, how it's containerized with Docker,
      deployed to Fly.io via GitHub Actions, and how an associated iOS application is built and deployed
      to TestFlight using GitHub Actions.
    </p>

    <div class="section">
      <h2>1. Core Functionality: GitHub to Markdown</h2>
      <p>The primary function of <code>repo.md</code> is to convert a GitHub repository into a single Markdown file. Here's the process:</p>
      <ol>
        <li><strong>User Input & Backend Request:</strong>
          <ul>
            <li>The user submits a GitHub URL via the web interface (<code>index.html</code>).</li>
            <li>JavaScript on the frontend sends this URL via a POST request to the Flask backend (<code>app.py</code>) at the <code>/generate_markdown</code> endpoint.</li>
          </ul>
        </li>
        <li><strong>Repository Cloning & Processing:</strong>
          <ul>
            <li>The backend validates the URL and clones the repository into a temporary directory using <code>git clone --depth 1</code>.</li>
          </ul>
        </li>
        <li><strong>Markdown Generation (<code>scribe_core.py</code>):</strong>
          <ul>
            <li>The <code>scribe_core.py</code> module is invoked.</li>
            <li>It reads and respects <code>.gitignore</code> rules (using the <code>pathspec</code> library) to exclude specified files and directories.</li>
            <li>It recursively traverses the repository:
              <ul>
                <li>Directories are represented as Markdown headers (e.g., <code>## /path/to/dir/</code>).</li>
                <li>Readable text files are included within Markdown code blocks (<code>```</code>).</li>
                <li>Binary or unreadable files are marked as <code>[non-readable]</code>.</li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>Response & Display:</strong>
          <ul>
            <li>The generated Markdown, along with repository metadata (name, URL, timestamp), is sent back to the frontend as a JSON response. A watermark is added to the Markdown.</li>
            <li>The frontend JavaScript then displays this Markdown, offering "Copy to Clipboard" and "Download .md" buttons.</li>
          </ul>
        </li>
        <li><strong>Cleanup:</strong>
          <ul>
            <li>The temporary directory used for cloning the repository is deleted from the server.</li>
          </ul>
        </li>
      </ol>
      <p>This diagram illustrates the core web application flow:</p>
      <div class="mermaid">
        graph LR
            A[User enters GitHub URL in Frontend (index.html)] --> B{Frontend JS (index.html)};
            B -- POST /generate_markdown --> C[Flask Backend (app.py)];
            C -- Validates URL & Clones Repo --> D[Temporary Directory];
            C -- Invokes --> E[Scribe Core (scribe_core.py)];
            E -- Reads .gitignore --> F{PathSpec Library};
            F -- Filters files --> E;
            E -- Recursively reads files/dirs --> G[Markdown String];
            G -- Adds Header/Timestamp --> C;
            C -- Returns JSON (Markdown + Repo Name) --> B;
            B -- Displays Markdown & Buttons (index.html) --> H[User sees Markdown/Downloads];

            style A fill:#f9f,stroke:#333,stroke-width:2px
            style B fill:#ccf,stroke:#333,stroke-width:2px
            style C fill:#fcc,stroke:#333,stroke-width:2px
            style D fill:#ccc,stroke:#333,stroke-width:2px
            style E fill:#cfc,stroke:#333,stroke-width:2px
            style F fill:#cff,stroke:#333,stroke-width:2px
            style G fill:#ffc,stroke:#333,stroke-width:2px
            style H fill:#f9f,stroke:#333,stroke-width:2px
      </div>
    </div>

    <div class="section">
      <h2>2. Web Application Deployment to Fly.io</h2>
      <p>The <code>repo.md</code> web application is continuously deployed to <a href="https://fly.io" target="_blank" rel="noopener">Fly.io</a> using GitHub Actions. This ensures that the latest changes to the <code>main</code> branch are automatically built and made live.</p>
      <ol>
        <li><strong>Trigger:</strong> A push to the <code>main</code> branch automatically triggers the <code>.github/workflows/fly-deploy.yml</code> GitHub Action.</li>
        <li><strong>Action Steps:</strong>
          <ul>
            <li>The repository code is checked out.</li>
            <li>The Fly.io command-line tool (<code>flyctl</code>) is set up and authenticated using a <code>FLY_API_TOKEN</code> secret.</li>
            <li>The <code>flyctl deploy --remote-only</code> command is executed. This instructs Fly.io to:
              <ul>
                <li>Use the project's <code>Dockerfile</code> to build the application image on Fly.io's remote builders. The Dockerfile sets up Python, installs dependencies, and copies application code.</li>
                <li>Use <code>fly.toml</code> for deployment configuration (app name, region, services, VM resources).</li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>Live Application:</strong> Once deployed, the updated web application is live and accessible via its Fly.io URL.</li>
      </ol>
      <p>This diagram outlines the deployment process:</p>
      <div class="mermaid">
        graph TD
            A[Push to 'main' branch] --> B{GitHub Action: Fly Deploy};
            B -- Uses `actions/checkout@v4` --> C[Checkout Code];
            C --> D[Setup Flyctl (superfly/flyctl-actions/setup-flyctl@master)];
            D -- FLY_API_TOKEN secret --> E[Run `flyctl deploy --remote-only`];
            E -- Uses `/Dockerfile` & `/fly.toml` --> F[Fly.io Build & Deploy];
            F --> G[Application Live on Fly.io];

            style A fill:#aaffaa,stroke:#333,stroke-width:2px
            style B fill:#ffccaa,stroke:#333,stroke-width:2px
            style C fill:#aaaaff,stroke:#333,stroke-width:2px
            style D fill:#aaaaff,stroke:#333,stroke-width:2px
            style E fill:#aaaaff,stroke:#333,stroke-width:2px
            style F fill:#aaccaa,stroke:#333,stroke-width:2px
            style G fill:#aaffaa,stroke:#333,stroke-width:2px
      </div>
    </div>

    <div class="section">
      <h2>3. iOS App Build & Deployment to TestFlight (GoAF Demo)</h2>
      <p>
        The repository also includes a sophisticated CI/CD pipeline (<code>.github/workflows/ios.yml</code>)
        for building and deploying an associated iOS application to TestFlight. This app is part of the "GoAF" (Go App Framework) demo
        and uses Capacitor to wrap web content (likely a Go/WASM application) into a native iOS shell.
        Fastlane is used for build automation, and Fastlane Match for managing code signing certificates.
      </p>
      <ol>
        <li><strong>Trigger:</strong>
          <ul>
            <li>The <code>ios.yml</code> workflow is triggered automatically on pushes to the <code>main</code> branch if relevant files (<code>.go, .html, .js, .css</code>) change.</li>
            <li>It can also be manually dispatched with options for versioning and forcing a build.</li>
          </ul>
        </li>
        <li><strong>Pre-build Checks:</strong>
          <ul>
            <li>A <code>check_changes</code> job determines if the build should proceed based on the trigger type and inputs.</li>
            <li>A <code>check_match_setup</code> job verifies that the Fastlane Match repository (e.g., <code>bobbyhiddn/fastlane.git</code>, which stores encrypted signing assets) is initialized and accessible.</li>
          </ul>
        </li>
        <li><strong>Deployment Job (<code>deploy_ios</code>):</strong> This job runs on a <code>macos-15</code> runner if pre-checks pass.
          <ul>
            <li><strong>Versioning:</strong> Calculates the next app version (e.g., <code>1.0.1</code>) based on inputs or the current version stored as a GitHub environment variable (<code>CURRENT_VERSION</code> in the 'ios' environment). This variable is then updated via the GitHub API.</li>
            <li><strong>Web Asset Build:</strong>
              <ul>
                <li>Sets up Node.js and installs dependencies (<code>npm ci</code> in the <code>capacitor/</code> directory).</li>
                <li>Builds the web assets using <code>npm run build</code> (which typically runs Vite).</li>
                <li>Syncs these web assets into the native iOS project using <code>npx cap sync ios</code>.</li>
              </ul>
            </li>
            <li><strong>Native iOS Build & Signing (using Fastlane):</strong>
              <ul>
                <li>Sets up Ruby and installs gems (including Fastlane) from <code>capacitor/ios/App/Gemfile</code>.</li>
                <li>Creates a temporary macOS keychain for code signing.</li>
                <li>Installs CocoaPods dependencies (<code>pod install</code>).</li>
                <li>Creates a temporary App Store Connect API key file from GitHub secrets.</li>
                <li>Executes the <code>bundle exec fastlane closed_beta</code> lane (defined in <code>capacitor/ios/App/fastlane/Fastfile</code>). This lane performs several actions:
                  <ul>
                    <li>Configures App Store Connect API access.</li>
                    <li>Sets the app's marketing version and increments the build number in the Xcode project.</li>
                    <li>Uses Fastlane Match (<code>sync_code_signing</code>) to download and install the correct App Store distribution certificates and provisioning profiles from the secure Match Git repository.</li>
                    <li>Updates the Xcode project's code signing settings to use manual signing with the fetched profiles.</li>
                    <li>Builds the iOS app (<code>.ipa</code> file) configured for App Store distribution.</li>
                    <li>Uploads the <code>.ipa</code> to TestFlight and waits for Apple's processing to complete.</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><strong>Cleanup:</strong> Deletes the temporary keychain and the App Store Connect API key file.</li>
          </ul>
        </li>
      </ol>
      <p>This diagram shows the iOS deployment pipeline:</p>
      <div class="mermaid">
        graph TD
            subgraph Trigger
                A[Push to 'main' (specific paths)]
                B[Manual (workflow_dispatch) with inputs: version_type, custom_version, force_build]
            end

            subgraph Workflow_ios.yml
                C{Job: check_changes} --> D{Output: should_build};
                D -- If true --> E{Job: check_match_setup};
                E -- Checks bobbyhiddn/fastlane.git --> F{Output: is_initialized};
                F -- If true --> G{Job: deploy_ios};

                subgraph deploy_ios_Job
                    H[Checkout Code] --> I[Get CURRENT_VERSION (GitHub env var)];
                    I --> J[Calculate NEXT_VERSION];
                    J --> K[Update CURRENT_VERSION (GitHub API)];
                    K --> L[Setup Ruby & Bundler];
                    L --> M[Setup Node.js & npm ci];
                    M --> N[Build Web Assets (npm run build, npx cap sync ios)];
                    N --> O[Setup Temporary Keychain];
                    O --> P[Install iOS Dependencies (pod install)];
                    P --> Q[Create App Store Connect API Key JSON];
                    Q --> R[Run `bundle exec fastlane closed_beta`];
                    R -- Uses Fastfile, Appfile, Matchfile --> S[Build .ipa & Upload to TestFlight];
                    S --> T[Cleanup];
                end
            end

            A --> C;
            B --> C;

            style A fill:#aaffaa,stroke:#333,stroke-width:2px
            style B fill:#aaffaa,stroke:#333,stroke-width:2px
            style C fill:#ffccaa,stroke:#333,stroke-width:2px
            style E fill:#ffccaa,stroke:#333,stroke-width:2px
            style G fill:#ffccaa,stroke:#333,stroke-width:2px
            style R fill:#cceeff,stroke:#333,stroke-width:2px
      </div>
    </div>

    <p style="text-align: center; margin-top: 2rem;"><a href="/">Back to Home</a></p>
  </div>

  <footer class="footer">
    <p>Powered by Python & Flask. Inspired by GitHub.</p>
  </footer>
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      mermaid.initialize({
        startOnLoad: false, // We will call run manually
        theme: 'base', // Or 'default', 'forest', 'dark', 'neutral'
        themeVariables: {
          // Example: Customize colors if needed, though default should be fine
          // primaryColor: '#ff9900',
          // primaryTextColor: '#fff',
          // lineSpacing: '2px' // Example of a possible variable for spacing, check Mermaid docs
        }
      });
      // Ensure all diagrams are rendered.
      // If they are complex, might need a slight delay or ensure DOM is fully ready.
      setTimeout(() => {
        mermaid.run();
      }, 100); // Small delay just in case, usually not needed if startOnLoad:false
    });
  </script>
</body>
</html>