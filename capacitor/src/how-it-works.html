<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How repo.md Works | Convert GitHub Repo to Readme</title>
  <meta name="description" content="Learn how repo.md seamlessly converts GitHub repositories into clean, AI-friendly markdown documentation, and how it's deployed.">
  <link rel="canonical" href="https://repo-md.com/how-it-works" />
  <link rel="stylesheet" href="styles.css">
  <!-- Add JSON-LD Schema if applicable -->
</head>
<body>
  <header class="header">
    <a href="/" style="text-decoration: none; color: inherit;"><h1>repo.md</h1></a>
    <nav class="main-nav">
      <a href="/how-it-works.html">How It Works</a>
      <a href="/sponsor.html">Sponsor</a>
    </nav>
  </header>
  <div class="container">
    <h1>How repo.md Works</h1>
    <p class="intro">repo.md transforms GitHub repositories into comprehensive Markdown documents. This page delves into the technical details of its core functionality, how the web application is deployed to Fly.io, and how the companion iOS application is built and distributed to TestFlight.</p>

    <div class="section">
      <h2>1. Core Web App: GitHub URL to Markdown</h2>
      <p>The primary function of repo.md is to take a public GitHub repository URL and generate a single Markdown document representing its structure and content. This process is handled by a Python Flask backend.</p>
      <ol>
        <li><strong>User Input:</strong> A user enters a GitHub repository URL into the input field on the <a href="/">repo.md homepage</a> (<code>capacitor/src/index.html</code>).</li>
        <li><strong>API Request:</strong> Upon submission, the frontend JavaScript makes an asynchronous POST request to the <code>/generate_markdown</code> API endpoint.</li>
        <li><strong>Backend Processing (<code>app.py</code>):</strong>
          <ul>
            <li>The Flask application receives the GitHub URL.</li>
            <li>It creates a temporary directory to clone the repository.</li>
            <li>It uses a <code>subprocess</code> to execute <code>git clone --depth 1 <github_url> <temp_dir></code>. This clones only the latest commit to save time and space.</li>
            <li>If the clone is successful, it calls the <code>read_directory_to_markdown</code> function from <code>scribe_core.py</code>.</li>
          </ul>
        </li>
        <li><strong>Markdown Generation (<code>scribe_core.py</code>):</strong>
          <ul>
            <li>The <code>read_directory_to_markdown</code> function recursively traverses the cloned repository's directory structure.</li>
            <li>It respects <code>.gitignore</code> files found in the repository root to exclude unwanted files and directories, using the <code>pathspec</code> library.</li>
            <li>For each file, it checks if it's readable as text. Binary or unreadable files are marked as such.</li>
            <li>Readable file contents are embedded within Markdown code blocks, prefixed by a header indicating their path. Directories are represented as Markdown headers.</li>
            <li>The function returns a single, large Markdown string.</li>
          </ul>
        </li>
        <li><strong>Response:</strong> <code>app.py</code> sends the generated Markdown content (and the repository name) back to the frontend as a JSON response.</li>
        <li><strong>Display:</strong> The frontend JavaScript populates a <code><pre><code></code> block with the received Markdown and enables the "Copy to Clipboard" and "Download .md" buttons.</li>
        <li><strong>Cleanup:</strong> The temporary directory used for cloning is removed from the server.</li>
      </ol>
      <p>The following diagram shows how a GitHub repository URL is processed by repo.md to generate Markdown content:</p>
      <div class="mermaid">
        flowchart TB
          subgraph "ðŸ“± Web App"
            A["App"] --> B["URLInput"]
            A --> C["MarkdownViewer"]
            B --> D["APIService"]
            D --> C
          end

          style A fill:#61dafb20,stroke:#61dafb
          style B fill:#61dafb20,stroke:#61dafb
          style C fill:#61dafb20,stroke:#61dafb
          style D fill:#61dafb20,stroke:#61dafb
      </div>
    </div>

    <div class="section">
      <h2>2. Web App Deployment to Fly.io</h2>
      <p>The repo.md web application is containerized using Docker and deployed to the Fly.io platform. This process is automated via a GitHub Actions workflow.</p>
      <ol>
        <li><strong>Trigger:</strong> A push to the <code>main</code> branch of the GitHub repository triggers the <code>.github/workflows/fly-deploy.yml</code> workflow.</li>
        <li><strong>GitHub Actions Workflow:</strong>
          <ul>
            <li>The job runs on an <code>ubuntu-latest</code> runner.</li>
            <li><code>actions/checkout@v4</code>: The repository code is checked out.</li>
            <li><code>superfly/flyctl-actions/setup-flyctl@master</code>: The Fly.io command-line tool (<code>flyctl</code>) is installed and configured.</li>
            <li><code>flyctl deploy --remote-only</code>: This command instructs Fly.io to build and deploy the application.
              <ul>
                <li>Fly.io uses the <code>Dockerfile</code> present in the root of the repository for building.</li>
                <li>The <code>FLY_API_TOKEN</code> secret is used for authentication.</li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>Docker Build (defined in <code>Dockerfile</code>):</strong>
          <ul>
            <li>Starts from a <code>python:3.11-slim</code> base image.</li>
            <li>Installs <code>git</code> (for the cloning functionality of the app itself).</li>
            <li>Copies <code>requirements.txt</code> and installs Python dependencies (Flask, pathspec, gunicorn).</li>
            <li>Copies the backend application files (<code>app.py</code>, <code>scribe_core.py</code>).</li>
            <li>Copies the frontend static assets from <code>capacitor/src/</code> into the image at <code>/app/capacitor/src/</code>. Flask is configured to serve these.</li>
            <li>Exposes port <code>8080</code>.</li>
            <li>The <code>CMD</code> is set to <code>["gunicorn", "--bind", "0.0.0.0:8080", "app:app"]</code> to run the Flask app using Gunicorn.</li>
          </ul>
        </li>
        <li><strong>Fly.io Deployment (configured in <code>fly.toml</code>):</strong>
          <ul>
            <li>The application is named <code>repo-md</code> and primarily runs in the <code>den</code> (Denver) region.</li>
            <li>The HTTP service listens on internal port <code>8080</code>, forces HTTPS, and auto-starts/stops machines based on traffic.</li>
            <li>Virtual machines are configured with 1GB RAM and 1 shared CPU.</li>
          </ul>
        </li>
        <li><strong>Live Application:</strong> Once deployed, the updated web application is live on <a href="https://repo-md.com" target="_blank">repo-md.com</a>.</li>
      </ol>
      <p>This diagram outlines the steps to deploy the repo.md web application to the Fly.io hosting platform:</p>
      <div class="mermaid">
        flowchart TB
          subgraph "ðŸš€ Deployment"
            A["Local Code"] --> B["Docker Container"]
            B --> C["Fly.io Cloud"]
            C --> D["Live Website"]
          end

          style A fill:#ff950020,stroke:#ff9500
          style B fill:#ff950020,stroke:#ff9500
          style C fill:#ff950020,stroke:#ff9500
          style D fill:#ff950040,stroke:#ff9500
      </div>
    </div>

    <div class="section">
      <h2>3. iOS App Build & Deployment via GitHub Actions</h2>
      <p>repo.md also exists as an iOS application, built using Capacitor to wrap the web application. The build and deployment to TestFlight are automated using GitHub Actions and Fastlane.</p>

      <h3>3.1. Initial Setup: iOS Match Certificates (<code>ios-match-init.yml</code>)</h3>
      <p>This is a one-time (or infrequent) manual workflow to initialize code signing certificates and provisioning profiles using Fastlane Match. Match stores these securely in a separate private Git repository (<code>bobbyhiddn/fastlane</code>).</p>
      <ol>
        <li><strong>Manual Trigger:</strong> This workflow (<code>.github/workflows/ios-match-init.yml</code>) is run manually via <code>workflow_dispatch</code>.</li>
        <li><strong>Check Existing:</strong> It first checks if certificates/profiles for the <code>DEVELOPER_APP_IDENTIFIER</code> already exist in the Match repository to prevent duplicates.</li>
        <li><strong>Setup Certificates (if needed):</strong>
          <ul>
            <li>Runs on a <code>macos-latest</code> runner.</li>
            <li>Sets up Ruby and Bundler (for Fastlane).</li>
            <li>Creates a temporary keychain.</li>
            <li>Generates an App Store Connect API key file (<code>api_key.json</code>) using secrets.</li>
            <li>Runs <code>bundle exec fastlane match appstore</code> to generate and store new certificates and provisioning profiles in the Match repository.</li>
            <li>Cleans up the temporary keychain and API key file.</li>
          </ul>
        </li>
      </ol>

      <h3>3.2. iOS Deployment to TestFlight (<code>ios.yml</code>)</h3>
      <p>This workflow builds the iOS app and uploads it to TestFlight.</p>
      <ol>
        <li><strong>Trigger:</strong>
          <ul>
            <li>Push to the <code>main</code> branch if <code>.go</code>, <code>.html</code>, <code>.js</code>, or <code>.css</code> files change.</li>
            <li>Manual trigger via <code>workflow_dispatch</code> with options for version type (patch/minor/major), custom version, and force build.</li>
          </ul>
        </li>
        <li><strong>Pre-flight Checks:</strong>
          <ul>
            <li><code>check_changes</code>: Determines if a build should proceed based on trigger type and file changes.</li>
            <li><code>check_match_setup</code>: Verifies that the Fastlane Match repository (<code>secrets.MATCH_GIT_URL</code>) is initialized and accessible. Exits if not.</li>
          </ul>
        </li>
        <li><strong>Deploy iOS Job (<code>deploy_ios</code> on <code>macos-15</code>):</strong>
          <ol>
            <li><strong>Checkout & Versioning:</strong>
              <ul>
                <li>Code is checked out.</li>
                <li>The current version is fetched from a GitHub environment variable (<code>vars.CURRENT_VERSION</code>).</li>
                <li>The next version is calculated based on the input (patch, minor, major, or custom).</li>
                <li>The <code>CURRENT_VERSION</code> variable in the 'ios' GitHub environment is updated to this new version via the GitHub API.</li>
              </ul>
            </li>
            <li><strong>Environment Setup:</strong>
              <ul>
                <li>Ruby (for Fastlane) and Node.js (for Capacitor/frontend build) are set up.</li>
                <li>Frontend dependencies are installed (<code>npm ci</code> in <code>capacitor/</code>).</li>
              </ul>
            </li>
            <li><strong>Build & Sync Web Assets:</strong>
              <ul>
                <li><code>npm run build</code>: The web app (Vite) is built into the <code>capacitor/dist</code> directory.</li>
                <li><code>npx cap sync ios</code>: Capacitor copies web assets to the native iOS project (<code>capacitor/ios/App/App/public/</code>) and updates native project configurations. The <code>copy-assets.js</code> script also plays a role here, ensuring WASM files are correctly placed for Capacitor.</li>
              </ul>
            </li>
            <li><strong>Native iOS Setup:</strong>
              <ul>
                <li>A temporary keychain is created and configured.</li>
                <li>iOS dependencies (CocoaPods) are installed (<code>pod install</code> in <code>capacitor/ios/App</code>).</li>
                <li>An App Store Connect API key file (<code>api_key.json</code>) is created in <code>capacitor/ios/App/</code> for Fastlane.</li>
              </ul>
            </li>
            <li><strong>Fastlane Execution (<code>bundle exec fastlane closed_beta</code>):</strong>
              <ul>
                <li>This command is run from <code>capacitor/ios/App</code>.</li>
                <li><strong><code>Appfile</code>:</strong> Configures <code>app_identifier</code>, <code>apple_id</code>, and <code>team_id</code> from environment variables.</li>
                <li><strong><code>Matchfile</code>:</strong> Configures Match to use the Git URL for certificates and specifies the <code>appstore</code> type.</li>
                <li><strong><code>Fastfile</code> (<code>closed_beta</code> lane):</strong>
                  <ul>
                    <li>Authenticates with App Store Connect using the API key.</li>
                    <li><code>increment_version_number</code>: Sets the app's marketing version in the Xcode project to <code>ENV['CUSTOM_VERSION']</code> (which is the calculated next version).</li>
                    <li><code>latest_testflight_build_number</code>: Fetches the current highest build number from TestFlight.</li>
                    <li><code>increment_build_number</code>: Sets the Xcode project's build number to (latest TestFlight build number + 1).</li>
                    <li><code>sync_code_signing</code> (match): Downloads certificates and provisioning profiles from the Match Git repository into the temporary keychain (<code>readonly: true</code>).</li>
                    <li><code>update_code_signing_settings</code>: Configures the Xcode project to use manual signing with the downloaded profile.</li>
                    <li><code>build_ios_app</code>: Compiles and archives the iOS application (<code>.ipa</code> file).</li>
                    <li><code>upload_to_testflight</code>: Uploads the <code>.ipa</code> to App Store Connect for TestFlight distribution and waits for processing.</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><strong>Cleanup:</strong> The temporary keychain and API key file are deleted.</li>
          </ol>
        </li>
      </ol>
      <p>This diagram illustrates the automated process of building the repo.md iOS application and deploying it to TestFlight using GitHub Actions:</p>
      <div class="mermaid">
        flowchart TB
          subgraph "ðŸ“± iOS App"
            A["Web App"] --> B["Capacitor Wrapper"]
            B --> C["Native iOS App"]
            C --> D["TestFlight"]
          end

          style A fill:#34c75920,stroke:#34c759
          style B fill:#34c75920,stroke:#34c759
          style C fill:#34c75920,stroke:#34c759
          style D fill:#34c75940,stroke:#34c759
      </div>
    </div>

    <p style="text-align: center; margin-top: 2rem;"><a href="/">Back to Home</a></p>
  </div>

  <footer class="footer">
    <p>Powered by Python & Flask. Inspired by GitHub.</p>
  </footer>
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      mermaid.initialize({
        startOnLoad: false // We will call run manually
      });
      mermaid.run();
    });
  </script>
</body>
</html>