<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How repo.md Works | Convert GitHub Repo to Readme</title>
  <meta name="description" content="Learn how repo.md seamlessly converts GitHub repositories into clean, AI-friendly markdown documentation, and how its GitOps workflows automate deployments.">
  <link rel="canonical" href="https://repo-md.com/how-it-works" />
  <link rel="stylesheet" href="styles.css">
  <!-- Add JSON-LD Schema if applicable -->
</head>
<body>
  <header class="header">
    <a href="/" style="text-decoration: none; color: inherit;"><h1>repo.md</h1></a>
    <nav class="main-nav">
      <a href="/how-it-works.html">How It Works</a>
      <a href="/sponsor.html">Sponsor</a>
    </nav>
  </header>
  <div class="container">
    <h1>How repo.md Works</h1>
    <p class="intro">repo.md transforms GitHub repositories into comprehensive Markdown documents. This page delves into the technical details of its core functionality and its GitOps-driven automated deployment pipelines for both the web application (to Fly.io) and the iOS application (to TestFlight).</p>

    <div class="section">
      <h2>1. Core Web App Functionality (Runtime)</h2>
      <p>The primary function of repo.md is to take a public GitHub repository URL and generate a single Markdown document representing its structure and content. This process is handled by a Python Flask backend when a user interacts with the live application.</p>
      <ol>
        <li><strong>User Input:</strong> A user enters a GitHub repository URL into the input field on the <a href="/">repo.md homepage</a> (<code>capacitor/src/index.html</code>).</li>
        <li><strong>API Request:</strong> Upon submission, the frontend JavaScript makes an asynchronous POST request to the <code>/generate_markdown</code> API endpoint of the deployed application.</li>
        <li><strong>Backend Processing (<code>app.py</code>):</strong>
          <ul>
            <li>The Flask application (running on Fly.io) receives the GitHub URL.</li>
            <li>It creates a temporary directory on the server.</li>
            <li>It uses a <code>subprocess</code> to execute <code>git clone --depth 1 <github_url> <temp_dir></code>. This clones only the latest commit of the *target repository* to save time and space.</li>
            <li>If the clone is successful, it calls the <code>read_directory_to_markdown</code> function from <code>scribe_core.py</code>.</li>
          </ul>
        </li>
        <li><strong>Markdown Generation (<code>scribe_core.py</code>):</strong>
          <ul>
            <li>The <code>read_directory_to_markdown</code> function recursively traverses the cloned repository's directory structure.</li>
            <li>It respects <code>.gitignore</code> files found in the repository root to exclude unwanted files and directories, using the <code>pathspec</code> library.</li>
            <li>For each file, it checks if it's readable as text. Binary or unreadable files are marked as such.</li>
            <li>Readable file contents are embedded within Markdown code blocks, prefixed by a header indicating their path. Directories are represented as Markdown headers.</li>
            <li>The function returns a single, large Markdown string.</li>
          </ul>
        </li>
        <li><strong>Response:</strong> <code>app.py</code> sends the generated Markdown content (and the repository name) back to the frontend as a JSON response.</li>
        <li><strong>Display:</strong> The frontend JavaScript populates a <code><pre><code></code> block with the received Markdown and enables the "Copy to Clipboard" and "Download .md" buttons.</li>
        <li><strong>Cleanup:</strong> The temporary directory used for cloning is removed from the server.</li>
      </ol>
      <p>The following diagram shows the runtime process of how a GitHub repository URL is processed by the deployed repo.md web app to generate Markdown content:</p>
      <div class="mermaid">
        flowchart TB
          subgraph "Web App (Runtime)"
            A["User opens repo.md website"] --> B["Enters GitHub URL"]
            A --> C["Views generated Markdown"]
            B --> D["Website logic (Frontend)"]
            D -- "Sends URL to server for processing" --> E["Server-side code (app.py on Fly.io)"]
            E -- "Server clones repo & creates Markdown" --> F["Markdown content ready"]
            F -- "Sends Markdown back to website" --> D
            D --> C
          end

          style A fill:#61dafb20,stroke:#61dafb
          style B fill:#61dafb20,stroke:#61dafb
          style C fill:#61dafb20,stroke:#61dafb
          style D fill:#61dafb20,stroke:#61dafb
          style E fill:#61dafb20,stroke:#61dafb
          style F fill:#61dafb20,stroke:#61dafb
      </div>
    </div>

    <div class="section">
      <h2>2. Web App GitOps Deployment to Fly.io</h2>
      <p>The repo.md web application's deployment to Fly.io is managed via a GitOps workflow. Changes pushed to the <code>main</code> branch automatically trigger a new build and deployment.</p>
      <ol>
        <li><strong>Git Push:</strong> A developer pushes code changes (e.g., to <code>app.py</code>, <code>scribe_core.py</code>, or frontend files in <code>capacitor/src/</code>) to the <code>main</code> branch of the repo.md GitHub repository.</li>
        <li><strong>GitHub Actions Trigger:</strong> This push automatically triggers the <code>.github/workflows/fly-deploy.yml</code> workflow.</li>
        <li><strong>Workflow Execution:</strong>
          <ul>
            <li>The repository code is checked out on an <code>ubuntu-latest</code> runner.</li>
            <li>The Fly.io CLI (<code>flyctl</code>) is set up.</li>
            <li><code>flyctl deploy --remote-only</code> is executed. This command tells Fly.io to:
                <ul>
                    <li>Pull the latest code from the <code>main</code> branch.</li>
                    <li>Build a new Docker image using the <code>Dockerfile</code> in the repository root. The <code>Dockerfile</code> defines how to package the Python backend (Flask, Gunicorn) and the static frontend assets.</li>
                    <li>Deploy this new image to the Fly.io infrastructure as defined in <code>fly.toml</code>.</li>
                </ul>
            </li>
          </ul>
        </li>
        <li><strong>Live Application:</strong> Once Fly.io successfully builds and deploys the new version, it becomes the live application accessible at <a href="https://repo-md.com" target="_blank">repo-md.com</a>.</li>
      </ol>
      <p>This GitOps deployment pipeline is visualized below:</p>
      <div class="mermaid">
        flowchart TB
          subgraph "Web App GitOps Deployment"
            A["Developer pushes code changes to Git"] -->|Triggers| B["GitHub Actions workflow starts (fly-deploy.yml)"];
            B -- "GitHub Actions workflow instructs Fly.io to deploy" --> C["Cloud platform (Fly.io) processes request"]
            C -- "Platform builds app container (Docker image)\n& deploys it to live servers" --> D["Updated website is live (repo-md.com)"]
          end

          style A fill:#0366d620,stroke:#0366d6
          style B fill:#ff950020,stroke:#ff9500
          style C fill:#6f42c120,stroke:#6f42c1
          style D fill:#2ea44f20,stroke:#2ea44f
      </div>
    </div>

    <div class="section">
      <h2>3. iOS App GitOps Build & Deployment</h2>
      <p>The repo.md iOS application, a Capacitor-wrapped version of the web app, also follows a GitOps approach for builds and deployments to TestFlight, leveraging GitHub Actions and Fastlane.</p>

      <h3>3.1. Prerequisite: iOS Code Signing (<code>ios-match-init.yml</code>)</h3>
      <p>Code signing is a critical part of iOS development. Fastlane Match is used to manage certificates and provisioning profiles, storing them securely in a separate private Git repository (<code>bobbyhiddn/fastlane</code>). This setup is an example of "Infrastructure as Code."</p>
      <ol>
        <li><strong>Manual Initialization:</strong> The <code>.github/workflows/ios-match-init.yml</code> workflow is run manually when new certificates are needed (e.g., initial setup, yearly renewal).</li>
        <li><strong>Certificate Generation:</strong> This workflow securely generates and stores the necessary signing identities and provisioning profiles in the dedicated Match Git repository.</li>
      </ol>

      <h3>3.2. Automated iOS Deployment to TestFlight (<code>ios.yml</code>)</h3>
      <p>Changes to the web application's codebase or manual triggers can initiate an automated build and deployment of the iOS app to TestFlight.</p>
      <ol>
        <li><strong>Git Push / Manual Trigger:</strong>
            <ul>
                <li>A push to the <code>main</code> branch (if relevant web app files like <code>.html</code>, <code>.js</code>, <code>.css</code>, or <code>.go</code> for potential WASM changes are modified) triggers the <code>.github/workflows/ios.yml</code> workflow.</li>
                <li>Alternatively, the workflow can be dispatched manually with versioning options.</li>
            </ul>
        </li>
        <li><strong>GitHub Actions Workflow Execution (<code>ios.yml</code>):</strong>
          <ul>
            <li>The workflow first checks if a build is necessary and if the Match repository is set up.</li>
            <li><strong>Web Asset Build:</strong> The latest web application code from the <code>main</code> branch is built (e.g., using Vite via <code>npm run build</code>).</li>
            <li><strong>Capacitor Sync:</strong> <code>npx cap sync ios</code> integrates these fresh web assets into the native iOS project structure.</li>
            <li><strong>Fastlane Execution:</strong> The <code>closed_beta</code> lane in <code>capacitor/ios/App/fastlane/Fastfile</code> is executed. Fastlane handles:
                <ul>
                    <li>Fetching code signing assets from the Match Git repository.</li>
                    <li>Incrementing app version and build numbers.</li>
                    <li>Building the native iOS application (<code>.ipa</code> file).</li>
                    <li>Uploading the <code>.ipa</code> to App Store Connect for TestFlight distribution.</li>
                </ul>
            </li>
          </ul>
        </li>
        <li><strong>TestFlight Release:</strong> Once App Store Connect processes the build, it becomes available to testers via TestFlight.</li>
      </ol>
      <p>This automated iOS build and deployment pipeline is shown below:</p>
      <div class="mermaid">
        flowchart TB
          subgraph "iOS App GitOps Build & Deployment"
            A["Developer pushes code or starts iOS build manually"] -->|Triggers| B["GitHub Actions workflow for iOS build begins (ios.yml)"];
            B -- "GitHub Actions workflow builds web parts,\nupdates iOS project,\n& runs Fastlane (iOS automation)" --> C["iOS App file created (.ipa)"];
            C -- "Fastlane securely signs & uploads app package" --> D["App available to testers on TestFlight / App Store"];
          end

          style A fill:#0366d620,stroke:#0366d6
          style B fill:#ff950020,stroke:#ff9500
          style C fill:#34c75920,stroke:#34c759
          style D fill:#34c75940,stroke:#34c759
      </div>
    </div>

    <p style="text-align: center; margin-top: 2rem;"><a href="/">Back to Home</a></p>
  </div>

  <footer class="footer">
    <p>Powered by Python & Flask. Inspired by GitHub.</p>
  </footer>
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      mermaid.initialize({
        startOnLoad: false // We will call run manually
      });
      mermaid.run();
    });
  </script>
</body>
</html>